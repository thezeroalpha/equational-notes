<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/mathjax/MathJax@2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <link rel="Stylesheet" type="text/css" href="style.css" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('pre.code').forEach(function(item) {
          hljs.highlightBlock(item)
        })
      });
    </script>
    <title>lambda-terms</title>
</head>
<body>
<style type="text/css">
nav a {
    text-align: left;
}
nav #name {
    text-align: right;
    float: right;
    font-style: italic;
}
</style>
    <nav>
    <a href="index.html">Index</a>
    <span id="name">Alex Balgavy</span>
    </nav>
    <hr>
    <div class="content">
    
<div id="Lambda terms"><h2 id="Lambda terms" class="header"><a href="#Lambda terms">Lambda terms</a></h2></div>
<div id="Lambda terms-abstraction"><h3 id="abstraction" class="header"><a href="#Lambda terms-abstraction">abstraction</a></h3></div>
<ul>
<li>
𝜆.M is function mapping of x to M

<li>
𝜆x.square x is function mapping of x to square x

</ul>

<div id="Lambda terms-application"><h3 id="application" class="header"><a href="#Lambda terms-application">application</a></h3></div>
<ul>
<li>
F M is application of function F to argument M

</ul>

<div id="Lambda terms-terms as trees"><h3 id="terms as trees" class="header"><a href="#Lambda terms-terms as trees">terms as trees</a></h3></div>
<p>
<img src="img/term-tree-1.png" alt="Term tree part 1" /> <img src="img/term-tree-2.png" alt="Term tree part 2" />
</p>

<p>
<code>@</code> is an application. <code>λx - x</code> is equivalent to writing <code>λx.x</code>.
</p>

<div id="Lambda terms-parentheses"><h3 id="parentheses" class="header"><a href="#Lambda terms-parentheses">parentheses</a></h3></div>
<ul>
<li>
application is associative to the left:

<ul>
<li>
<code>(M N P) —&gt; ((M N) P)</code>

</ul>
<li>
outermost parentheses are omitted

<ul>
<li>
<code>M N P —&gt; (M N P)</code>

</ul>
<li>
lambda extends to the right as far as possible

<ul>
<li>
<code>𝜆x.M N —&gt; 𝜆x.(M N)</code>

</ul>
<li>
combining lambdas is possible

<ul>
<li>
<code>𝜆xy.M —&gt; 𝜆x.𝜆y.M</code>

</ul>
<li>
start with most nested lambda

<ul>
<li>
<code>(𝜆x.𝜆y.M) —&gt; 𝜆x.(𝜆y.M))</code>

</ul>
</ul>

<div id="Lambda terms-currying"><h3 id="currying" class="header"><a href="#Lambda terms-currying">currying</a></h3></div>
<p>
reduces function with several arguments to functions with single arguments
</p>
<ul>
<li>
f: x =&gt; x+x —&gt; 𝜆x.x+x

<li>
g: (x,y) =&gt; x+y —&gt; 𝜆x.𝜆y.x+y

</ul>

<div id="Lambda terms-free/bound variables"><h3 id="free/bound variables" class="header"><a href="#Lambda terms-free/bound variables">free/bound variables</a></h3></div>
<p>
x is bound by the first 𝜆x above it in the term tree (bolded)
</p>
<ul>
<li>
𝜆x.<span id="Lambda terms-free/bound variables-x"></span><strong id="x">x</strong>

<li>
𝜆x.<span id="Lambda terms-free/bound variables-x x"></span><strong id="x x">x x</strong>

<li>
(𝜆x.<span id="Lambda terms-free/bound variables-x"></span><strong id="x">x</strong>)x

<li>
𝜆x.y <span id="Lambda terms-free/bound variables-x"></span><strong id="x">x</strong>

</ul>

<p>
variables that are not bound are free (such as <code>y</code> in the last example above)
</p>

<div id="Lambda terms-substitution"><h3 id="substitution" class="header"><a href="#Lambda terms-substitution">substitution</a></h3></div>
<p>
M[x := N] means: result of replacing all free x in M by N
</p>

<ul>
<li>
x[x := N] = N

<li>
a[x := N] = a

<li>
(P Q)[x := N] = (P[x := N]) (Q[x := N])

<li>
(𝜆x.P)[x := N] = 𝜆x.P

<li>
(𝜆y.P)[x := N] = 𝜆y.(P[y := N]) if x ≠ y

</ul>

<div id="Lambda terms-alpha conversion"><h3 id="alpha conversion" class="header"><a href="#Lambda terms-alpha conversion">alpha conversion</a></h3></div>
<p>
renaming <em>bound</em> variables (in case of possible name clashes)
</p>
<ul>
<li>
𝜆x.x = 𝜆y.y

<li>
(𝜆x.y)[y := x] = 𝜆z.x

</ul>

<p>
P =α Q only if Q can be obtained from P by finitely many changes of bound variables in context
</p>


<p>
beta-reduction (dynamic):
</p>
<ul>
<li>
(𝜆x.x)y —&gt;β y

<li>
(𝜆x.x)y —&gt;β y

<li>
(𝜆x.xz)y —&gt;β yz

<li>
(𝜆x.z)y —&gt;β z

</ul>

<p>
In general:
(𝜆x.M)N —&gt;β M[x := N]
</p>

    </div>
</body>
</html>
