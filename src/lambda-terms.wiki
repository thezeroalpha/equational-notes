%template math
== Lambda terms ==
=== abstraction ===
* ðœ†.M is function mapping of x to M
* ðœ†x.square x is function mapping of x to square x

=== application ===
* F M is application of function F to argument M

=== terms as trees ===
{{local:..//img/term-tree-1.png|Term tree part 1}} {{local:../img/term-tree-2.png|Term tree part 2}}

`@` is an application. `Î»x - x` is equivalent to writing `Î»x.x`.

=== parentheses ===
* application is associative to the left:
    * `(M N P) â€”> ((M N) P)`
* outermost parentheses are omitted
    * `M N P â€”> (M N P)`
* lambda extends to the right as far as possible
    * `ðœ†x.M N â€”> ðœ†x.(M N)`
* combining lambdas is possible
    * `ðœ†xy.M â€”> ðœ†x.ðœ†y.M`
* start with most nested lambda
    * `(ðœ†x.ðœ†y.M) â€”> ðœ†x.(ðœ†y.M))`

=== currying ===
reduces function with several arguments to functions with single arguments
* f: x => x+x â€”> ðœ†x.x+x
* g: (x,y) => x+y â€”> ðœ†x.ðœ†y.x+y

=== free/bound variables ===
x is bound by the first ðœ†x above it in the term tree (bolded)
* ðœ†x.*x*
* ðœ†x.*x x*
* (ðœ†x.*x*)x
* ðœ†x.y *x*

variables that are not bound are free (such as `y` in the last example above)

=== substitution ===
M[x := N] means: result of replacing all free x in M by N

* x[x := N] = N
* a[x := N] = a
* (P Q)[x := N] = (P[x := N]) (Q[x := N])
* (ðœ†x.P)[x := N] = ðœ†x.P
* (ðœ†y.P)[x := N] = ðœ†y.(P[y := N]) if x â‰  y

=== alpha conversion ===
renaming _bound_ variables (in case of possible name clashes)
* ðœ†x.x = ðœ†y.y
* (ðœ†x.y)[y := x] = ðœ†z.x

P =Î± Q only if Q can be obtained from P by finitely many changes of bound variables in context


beta-reduction (dynamic):
* (ðœ†x.x)y â€”>Î² y
* (ðœ†x.x)y â€”>Î² y
* (ðœ†x.xz)y â€”>Î² yz
* (ðœ†x.z)y â€”>Î² z

In general:
(ðœ†x.M)N â€”>Î² M[x := N]

